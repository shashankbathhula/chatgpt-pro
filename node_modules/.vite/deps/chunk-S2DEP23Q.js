import {
  BaseListChatMessageHistory,
  BaseMemory,
  getBufferString,
  getInputValue,
  getOutputValue
} from "./chunk-AVBPOKY3.js";

// node_modules/langchain/dist/stores/message/in_memory.js
var ChatMessageHistory = class extends BaseListChatMessageHistory {
  constructor(messages) {
    super(...arguments);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "stores", "message", "in_memory"]
    });
    Object.defineProperty(this, "messages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    this.messages = messages ?? [];
  }
  /**
   * Method to get all the messages stored in the ChatMessageHistory
   * instance.
   * @returns Array of stored BaseMessage instances.
   */
  async getMessages() {
    return this.messages;
  }
  /**
   * Method to add a new message to the ChatMessageHistory instance.
   * @param message The BaseMessage instance to add.
   * @returns A promise that resolves when the message has been added.
   */
  async addMessage(message) {
    this.messages.push(message);
  }
  /**
   * Method to clear all the messages from the ChatMessageHistory instance.
   * @returns A promise that resolves when all messages have been cleared.
   */
  async clear() {
    this.messages = [];
  }
};

// node_modules/langchain/dist/memory/chat_memory.js
var BaseChatMemory = class extends BaseMemory {
  constructor(fields) {
    super();
    Object.defineProperty(this, "chatHistory", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "returnMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "inputKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "outputKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.chatHistory = (fields == null ? void 0 : fields.chatHistory) ?? new ChatMessageHistory();
    this.returnMessages = (fields == null ? void 0 : fields.returnMessages) ?? this.returnMessages;
    this.inputKey = (fields == null ? void 0 : fields.inputKey) ?? this.inputKey;
    this.outputKey = (fields == null ? void 0 : fields.outputKey) ?? this.outputKey;
  }
  /**
   * Method to add user and AI messages to the chat history in sequence.
   * @param inputValues The input values from the user.
   * @param outputValues The output values from the AI.
   * @returns Promise that resolves when the context has been saved.
   */
  async saveContext(inputValues, outputValues) {
    await this.chatHistory.addUserMessage(getInputValue(inputValues, this.inputKey));
    await this.chatHistory.addAIChatMessage(getOutputValue(outputValues, this.outputKey));
  }
  /**
   * Method to clear the chat history.
   * @returns Promise that resolves when the chat history has been cleared.
   */
  async clear() {
    await this.chatHistory.clear();
  }
};

// node_modules/langchain/dist/memory/buffer_memory.js
var BufferMemory = class extends BaseChatMemory {
  constructor(fields) {
    super({
      chatHistory: fields == null ? void 0 : fields.chatHistory,
      returnMessages: (fields == null ? void 0 : fields.returnMessages) ?? false,
      inputKey: fields == null ? void 0 : fields.inputKey,
      outputKey: fields == null ? void 0 : fields.outputKey
    });
    Object.defineProperty(this, "humanPrefix", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Human"
    });
    Object.defineProperty(this, "aiPrefix", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AI"
    });
    Object.defineProperty(this, "memoryKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "history"
    });
    this.humanPrefix = (fields == null ? void 0 : fields.humanPrefix) ?? this.humanPrefix;
    this.aiPrefix = (fields == null ? void 0 : fields.aiPrefix) ?? this.aiPrefix;
    this.memoryKey = (fields == null ? void 0 : fields.memoryKey) ?? this.memoryKey;
  }
  get memoryKeys() {
    return [this.memoryKey];
  }
  /**
   * Loads the memory variables. It takes an `InputValues` object as a
   * parameter and returns a `Promise` that resolves with a
   * `MemoryVariables` object.
   * @param _values `InputValues` object.
   * @returns A `Promise` that resolves with a `MemoryVariables` object.
   */
  async loadMemoryVariables(_values) {
    const messages = await this.chatHistory.getMessages();
    if (this.returnMessages) {
      const result2 = {
        [this.memoryKey]: messages
      };
      return result2;
    }
    const result = {
      [this.memoryKey]: getBufferString(messages, this.humanPrefix, this.aiPrefix)
    };
    return result;
  }
};

export {
  ChatMessageHistory,
  BaseChatMemory,
  BufferMemory
};
//# sourceMappingURL=chunk-S2DEP23Q.js.map
